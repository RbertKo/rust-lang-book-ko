# 커져가는 프로젝트를 패키지, 크레이트, 모듈로 관리하기

거대한 프로그램을 작성할 때에는 코드 관리가 무척 중요합니다.
어느 시점부터는 머릿속에서 생각하는 것만으로는
전체 프로그램의 변화를 쫓아갈 수 없기 때문입니다.
코드에서 연관된 기능은 묶고 서로 다른 기능은 분리해두어야,
이후 특정 기능을 구현하는 코드를 찾거나 변경할 때 헤맬 필요 없습니다.

앞서 작성한 프로그램들은 하나의 모듈, 하나의 파일로 이루어져 있었지만,
프로젝트 규모가 커지면 코드를 여러 모듈, 여러 파일로 나누어 관리할 필요가 있습니다.
한 패키지 내에는 여러 바이너리 크레이트와 (원할 경우) 라이브러리 크레이트를 포함시킬 수 있으므로,
커진 프로젝트의 각 부분을 크레이트로 나눠서 외부 라이브러리처럼 쓸 수 있습니다.
이번 장에서 배워 볼 것은 이러한 기술들입니다.
상호연관된 패키지들로 이루어진 대규모 프로젝트의 경우,
14장 [“Cargo Workspaces”][workspaces]<!-- ignore --> 절에서 다룰 예정인,
Cargo에서 제공하는 Workspace 기능을 이용합니다.

그룹화 외에도, 세부 구현을 캡슐화하면 더 고수준으로 코드를 재사용할 수 있습니다.
어떤 작업을 구현해두고 다른 코드에서 해당 코드의 공개 인터페이스를 통해 호출하면,
세부적인 작동은 알 필요 없죠.
여러분은 어떤 부분을 다른 코드에서 사용할 수 있도록 공개하고,
어떤 부분을 비공개된 세부 구현으로 만들어 자유롭게 수정할 수 있도록
할지를 정의하는 방식으로 코드를 작성합니다.
머릿속에 담아두어야 하는 정보의 양을 줄이는 또 다른 방법이기도 합니다.

스코프 개념도 관련되어있습니다. 중첩된 컨텍스트에 작성한 코드는 "스코프 내" 정의된 다양한 이름들이 사용됩니다.
프로그래머나 컴파일러가 코드를 읽고, 쓰고, 컴파일할 때는 어떤 위치의 어떤 이름이 무엇을 의미하는지 알아야 합니다.
해당 이름이 변수인지, 함수인지, 열거형인지, 모듈인지, 상수인지, 그 외 요소인지 말이죠.
동일한 스코프 내에는 같은 이름을 가진 요소가 둘 이상 존재할 수 없기 때문에,
스코프를 의도적으로 생성해 어떤 이름은 스코프 내에 위치하고
어떤 이름은 스코프 밖에 위치하도록 조정하기도 합니다.
(이름 충돌을 해결하는 도구도 존재합니다)

러스트에는 코드 조직화에 필요한 기능이 여럿 있습니다.
어떤 세부 정보를 외부에 노출할지, 비공개로 둘지,
프로그램의 스코프 내 항목 이름 등 다양합니다.
이를 통틀어 *모듈 시스템* 이라 하며, 다음 기능들이 포함됩니다.

* **패키지** 크레이트를 빌드하고, 테스트하고, 공유하는데 사용하는 Cargo 기능입니다.
* **크레이트** 라이브러리나 실행 가능한 모듈로 구성된 트리 구조입니다.
* **모듈**, **use:** 구조, 스코프를 제어하고,
  조직세부 경로를 감추는 데 사용합니다.
* **경로** 구조체, 함수, 모듈 등의 이름을 지정합니다.

이번 장에서는 이 기능들을 모두 다뤄보면서 어떻게 작동하고,
어떻게 사용해서 스코프를 관리하는지 등을 배워보겠습니다.
이번 장을 마치고 나면, 모듈 시스템을 확실히 이해하고 스코프를 자유자재로 다룰 수 있을 거랍니다!

[workspaces]: ch14-03-cargo-workspaces.html
