## 모듈을 정의하여 스코프 및 공개 여부 제어하기

이번에는 모듈, 항목의 이름을 지정하는 *경로(path)*,
스코프에 경로를 가져오는 `use` 키워드,
항목을 공개하는 데 사용하는 `pub` 키워드를 알아보겠습니다.
`as` 키워드, 외부 패키지, 글롭 연산자 등도 다룰 예정이지만,
일단은 모듈에 집중하죠!

*모듈(module)* 은 가독성과 재사용성을 위해서 크레이트 내 코드를 그룹화하는 데 사용됩니다.
항목을 외부에 *공개(public)* 할지,
내부의 세부 구현이니 외부에서 사용할 수 없도록
*비공개(private)* 할지 제어하는 역할도 있습니다.

예시로, 레스토랑 기능을 제공하는
라이브러리 크레이트를 작성한다고 가정해보죠.
코드 구조에 집중할 수 있도록 레스토랑을 실제 코드로 구현하지는 않고,
본문은 비워둔 함수 시그니처만 정의하겠습니다.

레스토랑 업계에서는 레스토랑을 크게
*접객 부서(front of house)* 와 *지원 부서(back of house)* 로 나눕니다.
접객 부서는 호스트가 고객을 안내하고, 웨이터가 주문 접수 및 결제를 담당하고,
바텐더가 음료를 만들어 주는 곳입니다.
지원 부서는 셰프, 요리사, 주방보조가 일하는 주방과 매니저가 행정 업무를 하는 곳입니다.

함수를 중첩 모듈로 구성하면 크레이트 구조를 실제 레스토랑이 일하는 방식과 동일하게 구성할 수 있습니다.
`cargo new --lib restaurant` 명령어를 실행하여 `restaurant` 라는 새 라이브러리를 생성하고,
Listing 7-1 코드를 *src/lib.rs* 에 작성하여 모듈, 함수 시그니처를 정의합시다.


<span class="filename">Filename: src/lib.rs</span>

```rust,noplayground
{{#rustdoc_include ../listings/ch07-managing-growing-projects/listing-07-01/src/lib.rs}}
```

<span class="caption">Listing 7-1: 함수를 포함하는 별도의 모듈을 포함한
`front_of_house` 모듈</span>

`mod` 키워드와 모듈 이름(이 경우 `front_of_house`)을 명시하고,
본문을 중괄호로 감싸 모듈을 정의하였습니다.
`hosting`, `serving` 모듈처럼,
모듈 내에는 다른 모듈을 넣을 수 있습니다.
모듈은 구조체, 열거형, 상수, 트레잇, 함수(Listing 7-1처럼) 등의
항목 정의를 지닐 수 있습니다.

모듈은 관련된 정의들을 하나로 묶고,
어떤 연관성이 있는지 이름을 지어줄 수 있습니다.
모듈화된 코드를 사용하는 프로그래머가 자신에게 필요한 어떠한 정의를 찾을 때,
모든 정의를 읽어 내릴 필요 없이 그룹 기반으로 탐색할 수 있으므로 훨씬 쉽게 찾아낼 수 있죠.
코드에 새로운 기능을 추가하려는 프로그래머도 자신이 어디에 코드를 작성해야
프로그램 구조를 망치지 않을지 파악할 수 있습니다.

앞서 *src/main.rs*, *src/lib.rs* 는
크레이트 루트 파일이라 했던 걸 기억하시나요?
이 두 파일이 그런 이름을 갖게 된 이유는 크레이트 모듈 구조의 최상위(root)에 위치한
`crate` 라는 이름을 갖는 일종의 모듈을 형성하기 때문입니다.

Listing 7-2는 Listing 7-1의 구조를 모듈 트리로 나타낸 모습입니다.

```text
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

<span class="caption">Listing 7-2: Listing 7-1 코드를 모듈 트리로
나타낸 모습</span>

트리는 모듈이 서로 어떻게 중첩되어 있는지 보여줍니다
(예시: `hosting` 모듈은 `front_of_house` 내에 위치함).
`hosting`, `serving` 모듈이 둘 다 동일하게 `front_of_house` 모듈 내에 위치한 것처럼,
어떤 모듈이 *형제* 관계에 있는지 나타내기도 합니다.
가족 관계로 계속 비유하면, 모듈 A가 모듈 B 내에 있을 경우,
모듈 A는 모듈 B의 *자식* 이며, 모듈 B는 모듈 A의 *부모* 라고 표현할 수 있습니다.
전체 모듈 트리 최상위에 `crate` 라는 모듈이 암묵적으로 위치한다는 점을
기억해두세요.

모듈 트리에서 컴퓨터 파일 시스템의 디렉토리 트리를 연상하셨다면, 적절한 비유입니다!
파일 시스템의 디렉토리처럼, 여러분은 모듈로 코드를 조직화합니다.
또한 디렉토리에서 파일을 찾는 것처럼,
우리는 모듈을 찾아낼 방법이 필요하죠.
